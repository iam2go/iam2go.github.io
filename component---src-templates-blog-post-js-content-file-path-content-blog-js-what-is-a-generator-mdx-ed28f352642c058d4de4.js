"use strict";(self.webpackChunkleego_dev_log=self.webpackChunkleego_dev_log||[]).push([[402],{3850:function(e,t,n){n.r(t),n.d(t,{Head:function(){return v},default:function(){return x}});var l=n(1151),a=n(7294);function r(e){const t=Object.assign({h1:"h1",a:"a",span:"span",pre:"pre",code:"code",ul:"ul",li:"li",p:"p",strong:"strong",br:"br"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h1,{id:"generator-",style:{position:"relative"}},a.createElement(t.a,{href:"#generator-","aria-label":"generator  permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generator 👀"),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"function* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n")),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"일반 함수는 ",a.createElement(t.code,null,"function")," 키워드로 시작한다면, 제너레이터 함수는 ",a.createElement(t.code,null,"function*")," 키워드로 시작한다. (화살표 함수는 사용할 수 없다.)"),"\n",a.createElement(t.li,null,"제너레이터 함수 안에는 ",a.createElement(t.code,null,"yield")," 구문이 존재한다. ",a.createElement(t.code,null,"yield")," 구문의 문법은 ",a.createElement(t.code,null,"return")," 구문과 비슷하다. 차이점은 ",a.createElement(t.code,null,"return"),"은 한번만 실행되지만, 제너레이터 함수의 ",a.createElement(t.code,null,"yield"),"는 여러번 실행된다는 것이다. ",a.createElement(t.code,null,"yield")," 구문은 제너레이터의 실행을 멈췄다가 다음에 다시 시작할 수 있게 만든다."),"\n"),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"제너레이터 함수는 일반 함수와 동작 방식이 다른데, 제너레이터 함수를 호출하면 코드가 실행되지 않고, ",a.createElement(t.strong,null,"제너레이터 객체가 반환"),"된다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"let generator = generateSequence();\n")),"\n",a.createElement(t.p,null,"window console창에 ",a.createElement(t.code,null,"console.dir(generator)"),"를 찍어보면 아래와 같이 제너레이터 객체를 반환하는 것을 알 수 있다."),"\n",a.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcW2GnF%2Fbtrd149YS60%2FIobORMbIgQzZsWhDnke4M0%2Fimg.png",width:"512",className:"m-auto"}),"\n",a.createElement(t.p,null,"이 제너레이터 객체는 이터러블(iterable)이면서 동시에 이터레이터(iterator)인 객체이다. 따라서 ",a.createElement(t.code,null,"next")," 메소드를 호출하기 위해 ",a.createElement(t.code,null,"Symbol.iterator"),"메소드로 이터레이터를 별도 생성할 필요가 없다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"console.log(generator.next());\n// {value: 1, done: false}\n\nconsole.log(generator.next());\n// {value: 2, done: false}\n\nconsole.log(generator.next());\n// {value: 3, done: true}\n")),"\n",a.createElement(t.p,null,"제너레이터 객체의 ",a.createElement(t.code,null,".next()")," 메소드를 호출할 때마다, 제너레이터 객체는 스스로 깨어나서 다음번 ",a.createElement(t.code,null,"yield"),"문에 다다를 때까지 실행된다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"for(let value of generator) {\n console.log(value); // 1, 2\n}\n")),"\n",a.createElement(t.p,null,"참고로 ",a.createElement(t.code,null,"generator"),"를 for-of문으로 돌리면 1, 2까지만 출력된다. 이유는 for-of 이터레이션이 ",a.createElement(t.code,null,"done: true"),"일 때 마지막 ",a.createElement(t.code,null,"value"),"를 무시하기 때문이다. 그러므로 for-of를 사용했을 때 모든 값이 출력되길 원한다면 ",a.createElement(t.code,null,"yield"),"로 값을 반환해야한다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"generator를-통한-데이터-전달",style:{position:"relative"}},a.createElement(t.a,{href:"#generator%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EB%8B%AC","aria-label":"generator를 통한 데이터 전달 permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generator를 통한 데이터 전달🛵"),"\n",a.createElement(t.p,null,"이터레이터의 ",a.createElement(t.code,null,"next()"),"와 다르게 제너레이터 객체의 ",a.createElement(t.code,null,"next()"),"는 인수를 전달할 수도 있다.",a.createElement(t.br),"\n",a.createElement(t.code,null,"next()"),"를 호출할 때 인수로 값을 지정하면 ",a.createElement(t.code,null,"yield")," 키워드가 있는 대입문에 값이 할당된다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'function* generator(){\n    console.log("start");\n    const x = yield 1;\n    console.log("x="+x);\n    const y = yield (x + 1);\n    console.log("y="+y);\n    const z = yield (y+2);\n    console.log("z="+z);\n}\n\nconst gen = generator();\n\nconsole.log(gen.next());\n// start\n// {value: 1, done: false}\n\nconsole.log(gen.next(10));\n// x=10\n// {value: 11, done: false}\n\nconsole.log(gen.next(20));\n//y=20\n// {value: 22, done: false}\n\nconsole.log(gen.next(30));\n//z=30\n// {value: undefined, done: true}\n')),"\n",a.createElement(t.p,null,"이터레이터의 ",a.createElement(t.code,null,"next")," 메소드는 이터러블의 데이터를 꺼내 온다. 이에 반해 제너레이터의 ",a.createElement(t.code,null,"next")," 메소드에 인수를 전달하면 제너레이터 객체에 데이터를 밀어 넣는다."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"위 코드를 이해할 수 있는가?"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"gen.next()"),"를 처음 호출하면 첫번째 ",a.createElement(t.code,null,"yield"),"를 만나 멈춘다. 동시에 ",a.createElement(t.code,null,"yield")," ",a.createElement(t.strong,null,"뒤의 값을 ",a.createElement(t.code,null,"value"),"로 가져온다"),". 그래서 ",a.createElement(t.code,null,"console"),"에 찍히는 이터레이터 객체는 ",a.createElement(t.code,null,"{value: 1, done: false}")," 이다."),"\n",a.createElement(t.p,null,"두번째로 호출하며 인수로 10을 전달해주었다( ",a.createElement(t.code,null,"console.log(gen.next(10))")," ). ",a.createElement(t.strong,null,"전달한 인수는 첫번째 ",a.createElement(t.code,null,"yield"),"에 할당"),"된다.( x의 값이 10이된다.) 실행은 두번째 ",a.createElement(t.code,null,"yield"),"를 만나서 멈춘다. ",a.createElement(t.strong,null,"동시에 두번째 ",a.createElement(t.code,null,"yield")," 뒤의 ",a.createElement(t.code,null,"(x + 1)"),"을 ",a.createElement(t.code,null,"value"),"로 가져온다.")," "),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"generator와-무한-반복-",style:{position:"relative"}},a.createElement(t.a,{href:"#generator%EC%99%80-%EB%AC%B4%ED%95%9C-%EB%B0%98%EB%B3%B5-","aria-label":"generator와 무한 반복  permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generator와 무한 반복 🔁"),"\n",a.createElement(t.p,null,"보통의 코드에서 ",a.createElement(t.code,null,"while(true)"),"는 무한 루프에 빠질 위험이 있으므로 사용을 피한다. 하지만 Generator 안에서는 ",a.createElement(t.code,null,"yield"),"로 각 단계의 반복을 제어할 수 있기 때문에, ",a.createElement(t.code,null,"while(true)"),"를 활용하여 무한으로 사용 가능한 로직을 만들 수 있다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"function* getId() {\n  let i = 0;\n  while(true) {\n    yield ++i;\n  }\n}\n\nconst id = getId();\n\nconsole.log(id.next().value); //1\nconsole.log(id.next().value); //2\nconsole.log(id.next().value); //3\n")),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"참고-",style:{position:"relative"}},a.createElement(t.a,{href:"#%EC%B0%B8%EA%B3%A0-","aria-label":"참고  permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"참고 📌"),"\n",a.createElement(t.p,null,a.createElement(t.a,{href:"http://hacks.mozilla.or.kr/2015/08/es6-in-depth-generators/"},"http://hacks.mozilla.or.kr/2015/08/es6-in-depth-generators/"),a.createElement(t.br),"\n",a.createElement(t.a,{href:"http://hacks.mozilla.or.kr/2016/02/es6-in-depth-generators-continued/"},"http://hacks.mozilla.or.kr/2016/02/es6-in-depth-generators-continued/")))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)},o=n(1883),m=n(157),s=n(588),i=n(8709),d=n(9357),u=n(7174),E=n(4462),g=n(8336),h=n(1075);const p={img:e=>{let{src:t,alt:n}=e;return a.createElement("img",{src:t,alt:n,className:"m-auto md:w-3/4"})},pre:E.d,code:e=>a.createElement("code",Object.assign({},e,{className:"bg-background-primary text-accent-default bg-opacity-70"}))},f=e=>{var t;let{data:{previous:n,next:r,site:c,mdx:d},location:E,children:f}=e;const v=(null===(t=c.siteMetadata)||void 0===t?void 0:t.title)||"Title";return a.createElement(i.Z,{location:E,title:v},a.createElement("article",{className:"blog-post px-8 pt-10",itemScope:!0,itemType:"http://schema.org/Article"},a.createElement("header",{className:"text-center py-14"},a.createElement("h1",{itemProp:"headline"},d.frontmatter.title),a.createElement("p",{className:"text-accent-default text-xs mt-8"},d.frontmatter.date)),a.createElement("section",{className:"h-fit my-28 text-text-default",itemProp:"articleBody"},a.createElement(l.Zo,{components:p},f)),a.createElement(u.a,null,d.frontmatter.tags.map((e=>a.createElement(u.V,{key:e,text:e})))),a.createElement("hr",{className:"my-10"}),a.createElement(g.Z),a.createElement("footer")),a.createElement("nav",{className:"blog-post-nav px-8 mt-8"},a.createElement("ul",{className:"flex flex-wrap justify-between list-none p-0 text-text-default"},n?a.createElement(o.Link,{to:n.fields.slug,rel:"prev"},a.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},a.createElement(s.D,{size:22,className:"text-accent-default"}),a.createElement("p",{className:"max-w-[28rem]"},n.frontmatter.title))):a.createElement("div"),r&&a.createElement(o.Link,{to:r.fields.slug,rel:"next"},a.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},a.createElement("p",{className:"max-w-[28rem]"},r.frontmatter.title),a.createElement(m.M,{size:22,className:"text-accent-default"}))))),a.createElement(h.Z,{contents:d.tableOfContents}))},v=e=>{let{data:{mdx:t}}=e;return a.createElement(d.Z,{title:t.frontmatter.title,description:t.frontmatter.description||t.excerpt})};function x(e){return a.createElement(f,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-js-what-is-a-generator-mdx-ed28f352642c058d4de4.js.map