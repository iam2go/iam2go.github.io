"use strict";(self.webpackChunkleego_dev_log=self.webpackChunkleego_dev_log||[]).push([[12],{4736:function(e,t,n){n.r(t),n.d(t,{Head:function(){return b},default:function(){return v}});var l=n(1151),r=n(7294);function a(e){const t=Object.assign({p:"p",h1:"h1",a:"a",span:"span",ol:"ol",li:"li",h2:"h2",strong:"strong",img:"img",code:"code",blockquote:"blockquote",ul:"ul",pre:"pre"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"다크 모드는 어두운 배경을 중심으로 전반적인 요소를 어두운 색상 체계로 구성한 low-light UI를 지칭한다."),"\n",r.createElement(t.p,null,"스마트폰과 같은 디바이스의 사용량이 증가면서, 눈의 피로를 덜어주고 집중력을 높여준다는 이유로 다크모드가 등장하였다. 현재는 수많은 웹사이트들이 다크모드를 옵션으로 제공하고 있으며, 이제는 모든 서비스들의 필수 항목처럼 되어가고 있다."),"\n",r.createElement(t.p,null,"이 글은 기존 프로젝트에 styled-component와 context API를 사용하여 다크모드 옵션을 추가하는 과정을 담고 있다. 추가로 다크모드를 적용하기 전에, 지켜야 할 규칙과 가이드라인을 살펴본다."),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"다크모드-가이드라인",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8","aria-label":"다크모드 가이드라인 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"다크모드 가이드라인"),"\n",r.createElement(t.p,null,"다크모드를 개발하기 전에, 먼저 가이드라인을 찾아보았다."),"\n",r.createElement(t.p,null,"Material Deisgn의 다크모드 가이드라인을 참고하여 특히 주의해야 할 점들을 정리했다."),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"채도 감소: low-light UI에서는 색상이 더 두드러져 보이기 때문에 보다 가볍고 채도가 낮은 색상을 사용하는 것이 좋다. 채도가 높은 색상은 어두운 바탕에서 강하게 충돌하는 느낌이 드는데, 이를 경계가 ‘진동하는 것처럼 보인다' 고 표현한다."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"깊이: 다이얼로그는 보통 메인 화면 위로 표시된다. 보통 다이얼로그가 메인 화면의 위에 있다는 것을 표현하기 위해 다이얼로그를 제외한 배경을 Dimmed 처리한다. 하지만 이 방식은 다크모드에서는 효과를 보기 힘들다.\n다크모드에서 깊이감을 표현하기 위해서는 배경의 밝기에 변화를 준다. 상단의 레이어일수록 밝은 색을 적용하여 그 깊이를 표현할 수 있다."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"대비: 웹 콘텐츠 접근성 지침(이하 WCAG)을 위배하지 말아야 한다. WCAG에 따르면 텍스트를 시각적으로 표시할때의 대비율은 최소한 4.5 대 1이 되어야 한다."),"\n"),"\n"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"배경색과-기본-텍스트-색-정하기",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%B0%B0%EA%B2%BD%EC%83%89%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%89-%EC%A0%95%ED%95%98%EA%B8%B0","aria-label":"배경색과 기본 텍스트 색 정하기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"배경색과 기본 텍스트 색 정하기"),"\n",r.createElement(t.h2,{id:"배경색에-대한-고찰",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%B0%B0%EA%B2%BD%EC%83%89%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0","aria-label":"배경색에 대한 고찰 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"배경색에 대한 고찰"),"\n",r.createElement(t.p,null,"다크모드에서 가장 주의를 기울여야 하는 점은 명확한 대비를 통해 요소 간 구분이 쉽도록 하는 것이다."),"\n",r.createElement(t.p,null,"그렇다면 배경을 ",r.createElement(t.strong,null,"#000"),", 글씨를 ",r.createElement(t.strong,null,"#fff")," 로 하면 되지 않을까? 라고 생각하기 쉬운데, 오히려 완전한 검은색 배경에 흰색 텍스트는 눈의 피로를 극대화시킬 수 있다고 한다."),"\n",r.createElement(t.p,null,"개인적으로도 완전한 검은색 배경을 별로 좋아하지 않기 때문에 구글 다크모드 배경색인 ",r.createElement(t.strong,null,"#212426"),"을 사용하기로 결정하였다."),"\n",r.createElement(t.h2,{id:"기본-텍스트-색에-대한-고찰",style:{position:"relative"}},r.createElement(t.a,{href:"#%EA%B8%B0%EB%B3%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%89%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0","aria-label":"기본 텍스트 색에 대한 고찰 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"기본 텍스트 색에 대한 고찰"),"\n",r.createElement(t.p,null,"다크모드에서는 상단의 레이어일수록 밝은 색을 적용하여 그 깊이를 표현한다고 했다."),"\n",r.createElement(t.p,null,"높이의 단계가 4개나 5개인 경우 기본 텍스트(본문)와 기본 배경간에 최소 15.8:1의 대비 수준을 사용해야 가장 상단의 레이어와 기본 텍스트의 대비 수준이 4.5:1이 된다."),"\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fba9COc%2FbtrJn7bvwZi%2FHg3GADPQjKIaYR4dYJxio1%2Fimg.png",alt:""}),"\n",r.createElement(t.p,null,"현재 프로젝트는 본문과 다이얼로그 총 2단계의 높이를 가지기 때문에 기본 텍스트와 기본 배경의 대비가 15.8: 1 수준까지 나타날 필요가 없었다. 따라서 글씨 색은 무난하게 ",r.createElement(t.strong,null,"#FEFEFE"),"를 사용하기로 했다."),"\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcaqoRN%2FbtrJn7o6Zht%2FlzCdxkxKKnwSF5sSwZW421%2Fimg.pnghttps://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcaqoRN%2FbtrJn7o6Zht%2FlzCdxkxKKnwSF5sSwZW421%2Fimg.png",alt:""}),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"❗️ 한 가지 주의점은 어두운 배경의 밝은 텍스트는 밝은 곳에서 어두운 것보다 더 굵게 나타날 수 있다. 따라서 다크 모드에서는 ",r.createElement(t.code,null,"font-weight"),"값을 더 낮춰 사용하는 것이 좋다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"-프로젝트-색상-팔레트-만들기",style:{position:"relative"}},r.createElement(t.a,{href:"#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%89%EC%83%81-%ED%8C%94%EB%A0%88%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0","aria-label":" 프로젝트 색상 팔레트 만들기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"🎨 프로젝트 색상 팔레트 만들기"),"\n",r.createElement(t.p,null,"프로젝트 개발 초반에는 색상 팔레트를 만들지 않고 필요한 색을 그때그때 추가하여 사용했다."),"\n",r.createElement(t.p,null,"다크모드 기능을 도입하기위해서는 라이트 테마에서 정의한 색상과 다크 테마에서 정의한 색상이 1:1로 대치되어야했고, 그러려면 프로젝트에서 어떤 색상을 사용하는지 알아야했다. 우선 라이트모드와 다크모드 각각 필요한 색상을 모아서 색상 팔레트를 만들어보았다."),"\n",r.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7o6BB%2FbtrJqKGbXSn%2FRk2mRuv1Q6wbQQxU8wPIAk%2Fimg.png",width:"200",className:"m-auto"}),"\n",r.createElement(t.p,null,"위 이미지에서도 보이다시피 각 모드에 필요한 색상의 가짓수가 다르다. 이는 단순하게 ",r.createElement(t.strong,null,"#202124 → #fefefe")," 로 대치하듯 색상별로 1:1 대치하는 것이 불가능하다는 뜻이다."),"\n",r.createElement(t.p,null,"이 문제를 해결하기 위해 ",r.createElement(t.strong,null,"시맨틱 컬러"),"를 사용했다."),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"시맨틱 컬러란 컬러를 Hex값이 아닌 컬러가 사용되는 목적과 적용되는 UI에 따라 네이밍하고 시스템화하는 것 을 뜻하며, 간단하게 말해 ‘용도에 따른 색상 정의' 이다."),"\n"),"\n",r.createElement(t.p,null,"즉, #202124를 ‘gray-900’ 으로 정의하는 것이 아닌, ‘background’로 정의하여 그 목적을 이름에 담아주는 것이다."),"\n",r.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbupPwa%2FbtrJm7v9BZk%2FlOjNMhkNJd23hBsoB8k0R0%2Fimg.png",width:"50%",className:"m-auto"}),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"화면을 둘러보면서 색상 정의가 필요한 UI들을 정리해보았다."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"background"),"\n",r.createElement(t.li,null,"text( 본문 글씨, 로고, 아이콘 모두 같은 색 사용)"),"\n",r.createElement(t.li,null,"상태 3가지 ( correct, present, absent) + 텍스트는 #fefefe로 동일"),"\n",r.createElement(t.li,null,"보드 배경색, 텍스트 색, 테두리색(기본, 활성화 시)"),"\n",r.createElement(t.li,null,"키보드 배경색, 텍스트 색, hover시 배경색"),"\n",r.createElement(t.li,null,"다이얼로그 배경색"),"\n",r.createElement(t.li,null,"버튼 배경색, hover시 배경색, 텍스트색"),"\n"),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"정리한 UI를 토대로 용도별로 색상을 정의한 팔레트를 새로 만들어주었다."),"\n",r.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcJYkmM%2FbtrJp9ztVes%2FheXdozlf2lujWVe0DOG5Qk%2Fimg.png",width:"50%",className:"m-auto"}),"\n",r.createElement(t.p,null,"이제 우리는 위의 용도별 팔레트를 토대로 색상을 정의하여 프로젝트에 사용할 것이다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"프로젝트에-다크모드를-적용해보자",style:{position:"relative"}},r.createElement(t.a,{href:"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90","aria-label":"프로젝트에 다크모드를 적용해보자 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"프로젝트에 다크모드를 적용해보자🔥"),"\n",r.createElement(t.h2,{id:"-기존-style-폴더-구성",style:{position:"relative"}},r.createElement(t.a,{href:"#-%EA%B8%B0%EC%A1%B4-style-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%84%B1","aria-label":" 기존 style 폴더 구성 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"📁 기존 style 폴더 구성"),"\n",r.createElement(t.p,null,"다크모드를 도입하려는 프로젝트에서 style 폴더 하위에는 다음과 같이 두개의 파일이 존재한다."),"\n",r.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2P8Ql%2FbtrJqKlUA1H%2FLXv6pXpwlV9CQ10FdPsSc1%2Fimg.png",width:"300",className:"m-auto"}),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"GlobalStyle")," 파일에는 전역적으로 사용할 기본 스타일들을 설정해주었고,"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"import { createGlobalStyle } from \"./theme\";\n\nconst GlobalStyle = createGlobalStyle`\n    * {\n        font-size: 10px;\n    }\n    body{\n        font-family: 'Nunito','Pretendard', sans-serif;\n        margin: 0;\n        font-size: 12px;\n    }\n    h2{\n        font-size: 18px;\n    }\n    button{\n        cursor: pointer;\n        border: none;\n    }\n    div{\n        font-size: 12px;\n    }\n`;\n\nexport default GlobalStyle;\n")),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"theme")," 파일에는 공통으로 사용하는 색들을 정의해주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'import baseStyled, { ThemedStyledInterface } from "styled-components";\n\nexport const theme = {\n  color: {\n    correct: "#5babab",\n      present: "#fdb800",\n      absent: "#909090",\n  },\n};\n\nexport type Theme = typeof theme;\nexport const styled = baseStyled as ThemedStyledInterface<Theme>;\n')),"\n",r.createElement(t.p,null,"두 파일 모두 Root 컴포넌트에서 App컴포넌트를 감싸는 형태로, 아래와 같이 사용한다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'import React from "react";\nimport App from "./App";\nimport PortalContainer from "./components/modals/PortalContainer";\nimport GlobalStyle from "./style/GlobalStyle";\nimport { RecoilRoot } from "recoil";\nimport { ThemeProvider } from "styled-components";\nimport { theme } from "./style/theme";\n\nfunction Root() {\n  return (\n    <RecoilRoot>\n      <ThemeProvider theme={theme}>\n        <GlobalStyle />\n        <App />\n        <PortalContainer />\n      </ThemeProvider>\n    </RecoilRoot>\n  );\n}\n\nexport default Root;\n')),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"theme-색상-정의하기",style:{position:"relative"}},r.createElement(t.a,{href:"#theme-%EC%83%89%EC%83%81-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0","aria-label":"theme 색상 정의하기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"theme 색상 정의하기"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"theme.ts")," 안에 다크 테마와 라이트 테마의 색상을 정의해주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// styles/theme.ts\n\nimport * as styledComponents from "styled-components";\nimport { ThemedStyledComponentsModule } from "styled-components";\n\nconst color = {\n  correct: "#5babab",\n  present: "#fdb800",\n  absent: "#908790",\n};\n\nexport const light = {\n  background1: "#fefefe",\n  background2: "#fefefe", // 다이얼로그\n  text: "#202124",\n  keyBg1: "#e3e1e3",\n  KeyBg2: "#cfcbcf",\n  boardBg: "white",\n  boardBorder1: "#cfcbcf",\n  boardBorder2: "#202124", // 활성화시\n  button1: "#e3e1e3",\n  button2: "908790",\n  color: { ...color },\n};\n\nexport const dark = {\n  background1: "#202124",\n  background2: "#38393e", // 다이얼로그\n  text: "#fefefe",\n  keyBg1: "#403c40",\n  KeyBg2: "#766c76",\n  boardBg: "#131213",\n  boardBorder1: "#766c76",\n  boardBorder2: "#e3e1e3", // 활성화시\n  button1: "#5c565c",\n  button2: "#908790",\n  color: { ...color },\n};\n\nexport type Theme = typeof light;\nexport const { default: styled, createGlobalStyle } =\n  styledComponents as any as ThemedStyledComponentsModule<Theme>;\n')),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"export const styled = baseStyled as ThemedStyledInterface<Theme>;\n")),"\n",r.createElement(t.p,null,"기존에는 ",r.createElement(t.code,null,"ThemedStyledInterface")," 타입만을 가져와서 새롭게 선언해주었다면,"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"export const { default: styled, createGlobalStyle } =\n  styledComponents as any as ThemedStyledComponentsModule<Theme>;\n")),"\n",r.createElement(t.p,null,"다크모드를 추가하면서 ",r.createElement(t.code,null,"createGlobalStyle"),"에도 선언한 테마 색상 값을 사용하기 때문에 ",r.createElement(t.code,null,"ThemedStyledComponentsModule"),"을 가져와 테마 타입과 함께 export 해주었다."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"이런 설정과는 별개로 ",r.createElement(t.code,null,"styled-components.d.ts")," 파일을 만들어 테마 타입을 확장하는 방식을 사용해도 된다."),"\n"),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"styled-색상-정의-코드-변경하기",style:{position:"relative"}},r.createElement(t.a,{href:"#styled-%EC%83%89%EC%83%81-%EC%A0%95%EC%9D%98-%EC%BD%94%EB%93%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0","aria-label":"styled 색상 정의 코드 변경하기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"styled 색상 정의 코드 변경하기"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// Root.tsx\n\nimport React, {useState} from "react";\nimport App from "./App";\nimport PortalContainer from "./components/modals/PortalContainer";\nimport GlobalStyle from "./style/GlobalStyle";\nimport { RecoilRoot } from "recoil";\nimport { ThemeProvider } from "styled-components";\nimport { light, dark } from "./style/theme";\n\nfunction Root() {\nconst [theme, setTheme] = useState("light");\n  return (\n    <RecoilRoot>\n      <ThemeProvider theme={theme === "light" ? light : dark}>\n        <GlobalStyle />\n        <App />\n        <PortalContainer />\n      </ThemeProvider>\n    </RecoilRoot>\n  );\n}\n\nexport default Root;\n')),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"Root"),"컴포넌트에서 현재 테마를 담을 상태를 선언해주고, 그 값을 theme 속성으로 전달했다."),"\n",r.createElement(t.p,null,"이제 선택한 테마에 따라 ",r.createElement(t.code,null,"background"),"와 ",r.createElement(t.code,null,"text"),"색상이 변경되도록 코드를 변경해주자."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// style/GlobalStyle.ts\n\nimport { createGlobalStyle } from "./theme";\n\nconst GlobalStyle = createGlobalStyle`\n    ...\n    body{\n        ...\n        background: ${({ theme }) => theme.background1};\n        color: ${({ theme }) => theme.text};\n        transition: background 0.2s ease-in, color 0.2s ease-in;\n    }\n    ...\n`;\n\nexport default GlobalStyle;\n')),"\n",r.createElement(t.p,null,"❗️ 기존의 styled-component에서 ",r.createElement(t.code,null,"createGlobalStyle"),"을 가져와 사용하는 것이 아닌, ",r.createElement(t.code,null,"theme.ts"),"에서 export한 ",r.createElement(t.code,null,"createGlobalStyle"),"을 import해서 사용해야 한다."),"\n",r.createElement(t.p,null,"다른 컴포넌트에서도 색상을 정의해준 곳마다 동일하게 코드를 변경해주면 된다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// components/main/keyboard/Key.tsx\n\nimport React from "react";\nimport { styled } from "../../../style/theme";\n\n...\n\nfunction Key({ value, status, width = 4, onClick }: Props) {\n  ...\n    return(\n            <KeyBlock\n          width={width}\n          color={status}\n          ...\n        >\n          {value}\n        </KeyBlock>\n    )\n}\n\nconst KeyBlock = styled.div<StyleProps>`\n  background-color: ${({ theme }) => theme.keyBg1};\n  ...\n  &:hover {\n    background-color: ${({ theme }) => theme.KeyBg2};\n  }\n  &.on {\n    background-color: ${({ theme, color }) => color && theme.color[color]};\n    border-color: ${({ theme, color }) => color && theme.color[color]};\n    color: white;\n  }\n`;\n\nexport default Key;\n')),"\n",r.createElement(t.p,null,"❗️ 일반 컴포넌트 역시",r.createElement(t.code,null," theme.ts"),"에서 export한 ",r.createElement(t.code,null,"styled"),"를 import해서 사용해야 한다."),"\n",r.createElement(t.p,null,"변경을 끝냈다면 ",r.createElement(t.code,null,"Root"),"컴포넌트에서 theme의 기본 상태 값을 ",r.createElement(t.code,null,'"dark"'),"로 설정한 뒤 제대로 적용됐는지를 확인해보자."),"\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcJxyUo%2FbtrJn6wWywk%2F4aiaAvE2kQ5mLHNP2GstIk%2Fimg.png",alt:""}),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"토글-버튼-만들기",style:{position:"relative"}},r.createElement(t.a,{href:"#%ED%86%A0%EA%B8%80-%EB%B2%84%ED%8A%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0","aria-label":"토글 버튼 만들기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"토글 버튼 만들기"),"\n",r.createElement(t.p,null,"이제 테마 모드를 변경할 버튼을 만들어보자."),"\n",r.createElement(t.p,null,"이 프로젝트에서 기능 버튼은 모두 Header 안에 있다. Header의 가장 왼쪽에 버튼을 추가해 주었다.\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6x71F%2FbtrJpNQ9OVZ%2FoAa5w1bugAkCEGO4RPk1i0%2Fimg.png",alt:""}),"\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcTKCjc%2FbtrJm73W61r%2FaU3r1kQMBtIWDg36zeXgNK%2Fimg.png",alt:""})),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"Header"),"컴포넌트는 ",r.createElement(t.code,null,"Root"),"의 자식 컴포넌트 App의 자식 컴포넌트이다. theme값은 ",r.createElement(t.code,null,"Root"),"에서 사용하고, theme의 setter함수는  Root -> App을 거쳐 Header에서 사용해야 하는 상황이다. 아, 현재 테마 모드에 따라 아이콘을 바꿔줘야 하니 theme 값도 같이 넘겨줘야 한다."),"\n",r.createElement(t.p,null,"깔끔한 코드를 위해 theme를 전역 상태로 만들 필요가 있었다. 이 프로젝트에서는 전역 상태관리 라이브러리로 recoil을 사용하고 있지만, theme는 ",r.createElement(t.strong,null,"새로운 Context를 만들어 관리하는 방식"),"을 선택하였다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"usetheme-커스텀-hook-만들기",style:{position:"relative"}},r.createElement(t.a,{href:"#usetheme-%EC%BB%A4%EC%8A%A4%ED%85%80-hook-%EB%A7%8C%EB%93%A4%EA%B8%B0","aria-label":"usetheme 커스텀 hook 만들기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),r.createElement(t.code,null,"useTheme")," 커스텀 Hook 만들기"),"\n",r.createElement(t.p,null,"먼저, 테마의 토글 기능 처리를 위해 커스텀 Hook을 만들어주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// hooks/useTheme.ts\n\nimport { useCallback, useState } from "react";\n\nfunction useTheme() {\n  const [theme, setTheme] = useState("light");\n\n  const onChangeTheme = useCallback(() => {\n    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));\n  }, []);\n\n  return {\n    theme,\n    onChangeTheme,\n  };\n}\n\nexport default useTheme;\n')),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"새로운-themeprovider-만들기",style:{position:"relative"}},r.createElement(t.a,{href:"#%EC%83%88%EB%A1%9C%EC%9A%B4-themeprovider-%EB%A7%8C%EB%93%A4%EA%B8%B0","aria-label":"새로운 themeprovider 만들기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"새로운 ",r.createElement(t.code,null,"ThemeProvider")," 만들기"),"\n",r.createElement(t.p,null,"theme에 대한 context를 새롭게 생성하는 것과 동시에 기존 styled-component의 ",r.createElement(t.code,null,"ThemeProvider"),"를 커스텀해주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// context/ThemeProvider.tsx\n\nimport useTheme from "hooks/useTheme";\nimport React, { ReactNode } from "react";\nimport { light, dark } from "../style/theme";\nimport { ThemeProvider as StyledThemeProvider } from "styled-components";\n\ntype Props = {\n  children: ReactNode;\n};\n\nconst defaultValue = {\n  theme: "light",\n  onChangeTheme: () => {},\n};\n\nexport const ThemeContext = React.createContext(defaultValue);\n\nfunction ThemeProvider({ children }: Props) {\n  const themeProps = useTheme();\n\n  return (\n    <ThemeContext.Provider value={themeProps}>\n      <StyledThemeProvider theme={themeProps.theme === "light" ? light : dark}>\n        {children}\n      </StyledThemeProvider>\n    </ThemeContext.Provider>\n  );\n}\n\nexport default ThemeProvider;\n')),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"Root"),"컴포넌트의 ",r.createElement(t.code,null,"ThemeProvider"),"를 새로 커스텀한 ThemeProvider로 교체해준다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'import React from "react";\nimport App from "./App";\nimport PortalContainer from "./components/modals/PortalContainer";\nimport GlobalStyle from "./style/GlobalStyle";\nimport { RecoilRoot } from "recoil";\nimport ThemeProvider from "context/ThemeProvider";\n\nfunction Root() {\n  return (\n    <RecoilRoot>\n      <ThemeProvider>\n        <GlobalStyle />\n        <App />\n        <PortalContainer />\n      </ThemeProvider>\n    </RecoilRoot>\n  );\n}\n\nexport default Root;\n')),"\n",r.createElement(t.p,null,"다크모드 버튼이 있는 ",r.createElement(t.code,null,"Header"),"컴포넌트에 ",r.createElement(t.code,null,"useContext"),"로 ",r.createElement(t.code,null,"theme"),"값과 setter함수를 가져와서 셋팅해주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'import React, { useContext } from "react";\nimport styled from "styled-components";\nimport cn from "classnames";\nimport { ThemeContext } from "context/ThemeProvider";\n\nfunction Header() {\n  const { theme, onChangeTheme } = useContext(ThemeContext);\n  ...\n\n  return (\n    <HeaderStyle>\n      <Button onClick={onChangeTheme}>\n        <i\n          className={cn(\n            "fa-solid",\n            { "fa-sun": theme === "light" },\n            { "fa-moon": theme === "dark" }\n          )}\n        ></i>\n      </Button>\n      ...\n    </HeaderStyle>\n  );\n}\n...\n\nexport default Header;\n')),"\n",r.createElement(t.p,null,r.createElement(t.img,{src:"https://blog.kakaocdn.net/dn/ntTuK/btrJqK0u2R0/2cJnybhneFXVZRBA7K6fiK/img.gif",alt:""}),"\n이제 버튼을 누르면 라이트모드 ↔️ 다크모드로 전환되는것을 확인할 수 있다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"다크모드-설정-유지하기",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C-%EC%84%A4%EC%A0%95-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0","aria-label":"다크모드 설정 유지하기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"다크모드 설정 유지하기"),"\n",r.createElement(t.p,null,"다크모드로 설정한 상태에서 새로고침을 하면, 다크모드가 유지되지 않고 새롭게 라이트모드로 적용된다."),"\n",r.createElement(t.p,null,"사용자가 설정한 테마 값을 로컬스토리지에 저장하여 새로고침을 하더라도 이전에 설정한 테마 값이 유지되도록 변경해보자."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// hooks/useTheme.ts\n\nimport { useCallback, useLayoutEffect, useState } from "react";\n\nfunction useTheme() {\n  const [theme, setTheme] = useState("light");\n\n  const onChangeTheme = useCallback(() => {\n    const updatedTheme = theme === "light" ? "dark" : "light";\n    setTheme(updatedTheme);\n    localStorage.setItem("theme", updatedTheme);\n  }, [theme]);\n\n  useLayoutEffect(() => {\n    const savedTheme = localStorage.getItem("theme");\n    if (savedTheme && ["dark", "light"].includes(savedTheme)) {\n      setTheme(savedTheme);\n    }\n  }, []);\n\n  return {\n    theme,\n    onChangeTheme,\n  };\n}\n\nexport default useTheme;\n')),"\n",r.createElement(t.img,{src:"https://blog.kakaocdn.net/dn/dupvxY/btrJpM5Ovpz/sBVIxnctNtA4xWUynIgIp0/img.gif",alt:""}),"\n",r.createElement(t.p,null,"이제 새로고침 후에도 이전에 설정한 테마값이 잘 유지된다.",r.createElement("br"),"\n하지만 보는 사람에 따라 라이트모드 → 다크모드로 변환되는 효과가 거슬릴 수 있다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"새로고침-시-불필요한-전환효과를-없애자",style:{position:"relative"}},r.createElement(t.a,{href:"#%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8-%EC%8B%9C-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%A0%84%ED%99%98%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EC%97%86%EC%95%A0%EC%9E%90","aria-label":"새로고침 시 불필요한 전환효과를 없애자 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"새로고침 시 불필요한 전환효과를 없애자"),"\n",r.createElement(t.p,null,"새로고침 시에 라이트모드에서 다크모드로 전환 효과가 보여지는 이유는 테마를 부드럽게 변경하기 위해 설정한 ‘transition’ 때문이다."),"\n",r.createElement(t.p,null,"실제로 스타일에서 트랜지션을 제거하면 깜빡임 없이 다크모드가 유지되는 것을 볼 수 있다.\n",r.createElement(t.img,{src:"https://blog.kakaocdn.net/dn/bVhODn/btrJrQlCg2G/MHEMeBKD17cHFN0Z8kwva1/img.gif",alt:""})),"\n",r.createElement(t.p,null,"하지만 이 경우 테마의 전환 과정이 너무 부자연스럽게 느껴진다."),"\n",r.createElement(t.p,null,"트랜지션을 적용하면서 새로고침 시 전환효과가 일어나지 않게 하는 방법을 찾아야 했다."),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"useTheme"),"에서 우리는 테마의 초기값을 ",r.createElement(t.code,null,"“light”")," 로 설정해놨고, 렌더링 이후 로컬스토리지에 저장된 값을 가져와서 상태를 바꿔주었다. ",r.createElement(t.code,null,"“light”")," 에서 ",r.createElement(t.code,null,"“dark”")," 로 변하는 과정이 트렌지션으로 인하여 사용자의 눈에 포착된 것이다."),"\n",r.createElement(t.p,null,"그렇다면, 로컬스토리지에 저장된 값을 가져와서 상태를 바꾸는 일을 화면에 그리기 전에 수행하도록 바꿔주면 어떨까?"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"useEffect")," 가 아닌 ",r.createElement(t.code,null,"useLayoutEffect"),"를 사용해보자.\n",r.createElement(t.img,{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoBSCX%2FbtrJpOvMh1R%2FpaSd6IPbOPjgcXnt6mkg6k%2Fimg.png",alt:"React Hook의 실행 순서를 나타낸 그림"})),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"useEffect"),"가 컴포넌트가 렌더링되고 화면에 그려진 이후 비동기적으로 실행된다면,\n",r.createElement(t.code,null,"useLayoutEffect"),"는 렌더링된 컴포넌트가 화면에 그려지기 전에 동기적으로 실행된다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// hooks/useTheme.ts\n\nimport { useCallback, useLayoutEffect, useState } from "react";\n\nfunction useTheme() {\n  const [theme, setTheme] = useState("light");\n\n  const onChangeTheme = useCallback(() => {\n    const updatedTheme = theme === "light" ? "dark" : "light";\n    setTheme(updatedTheme);\n    localStorage.setItem("theme", updatedTheme);\n  }, [theme]);\n\n  useLayoutEffect(() => {\n    const savedTheme = localStorage.getItem("theme");\n    if (savedTheme && ["dark", "light"].includes(savedTheme)) {\n      setTheme(savedTheme);\n    }\n  }, []);\n\n  return {\n    theme,\n    onChangeTheme,\n  };\n}\n\nexport default useTheme;\n')),"\n",r.createElement(t.p,null,"body는 React가 제어하는 DOM node 밖의 요소이기 때문에 hook flow의 영향을 받지 않는다. ",r.createElement(t.code,null,"App")," 컴포넌트에 ",r.createElement(t.code,null,"<Background/>")," 요소를 추가하여 body에 배경을 넣었을 때와 동일하게 보이도록 해주었다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'// App.tsx\n\nimport Header from "./components/header";\nimport Main from "./components/main/Main";\nimport styled from "styled-components";\n\nfunction App() {\n  return (\n    <Background>\n      <Wrapper>\n        <Header />\n        <Main />\n      </Wrapper>\n    </Background>\n  );\n}\n\nconst Background = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: ${({ theme }) => theme.background1};\n  color: ${({ theme }) => theme.text};\n  transition: background 0.3s ease-in, color 0.3s ease-in;\n`;\n...\nexport default App;\n')),"\n",r.createElement(t.p,null,r.createElement(t.img,{src:"https://blog.kakaocdn.net/dn/CakvQ/btrJqnR0qXP/fOT0KoGK0JFiDba5OqmoEk/img.gif",alt:""}),"\ntransition 적용을 유지하면서, 새로고침 시에도 불필요한 테마 전환이 사라졌다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"-브라우저에-설정한-테마-값-가져오기",style:{position:"relative"}},r.createElement(t.a,{href:"#-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-%EC%84%A4%EC%A0%95%ED%95%9C-%ED%85%8C%EB%A7%88-%EA%B0%92-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0","aria-label":" 브라우저에 설정한 테마 값 가져오기 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"➕ 브라우저에 설정한 테마 값 가져오기"),"\n",r.createElement(t.p,null,"만약 프로젝트에 처음 들어오는 사용자가 시스템 설정으로 다크모드를 사용하고 있다면, 초기 테마를 시스템 설정과 동일하게 적용하는 것이 사용자에게 더 좋은 UX를 제공할 것이다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,'import { useCallback, useLayoutEffect, useState } from "react";\n\nfunction useTheme() {\n  const [theme, setTheme] = useState("light");\n...\n\n  useLayoutEffect(() => {\n    const savedTheme = localStorage.getItem("theme");\n    if (savedTheme && ["dark", "light"].includes(savedTheme)) {\n      setTheme(savedTheme);\n      return;\n    }\n    if (\n      window.matchMedia &&\n      window.matchMedia("(prefers-color-scheme: dark)").matches\n    ) {\n      setTheme("dark");\n    }\n  }, []);\n\n  return {\n    theme,\n    onChangeTheme,\n  };\n}\n\nexport default useTheme;\n')),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"prefers-color-scheme")," 미디어 쿼리를 사용하여 ",r.createElement(t.code,null,"prefers-color-scheme")," 값이 ",r.createElement(t.code,null,"‘dark’")," 라면 프로젝트 테마를 다크모드로 설정하는 코드를 추가하였다."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?r.createElement(t,e,r.createElement(a,e)):a(e)},c=n(1883),m=n(157),s=n(588),h=n(8709),i=n(9357),d=n(7174),E=n(4462),u=n(8336),p=n(1075);const f={img:e=>{let{src:t,alt:n}=e;return r.createElement("img",{src:t,alt:n,className:"m-auto md:w-3/4"})},pre:E.d,code:e=>r.createElement("code",Object.assign({},e,{className:"bg-background-primary text-accent-default bg-opacity-70"}))},g=e=>{var t;let{data:{previous:n,next:a,site:o,mdx:i},location:E,children:g}=e;const b=(null===(t=o.siteMetadata)||void 0===t?void 0:t.title)||"Title";return r.createElement(h.Z,{location:E,title:b},r.createElement("article",{className:"blog-post px-8 pt-10",itemScope:!0,itemType:"http://schema.org/Article"},r.createElement("header",{className:"text-center py-14"},r.createElement("h1",{itemProp:"headline"},i.frontmatter.title),r.createElement("p",{className:"text-accent-default text-xs mt-8"},i.frontmatter.date)),r.createElement("section",{className:"h-fit my-28 text-text-default",itemProp:"articleBody"},r.createElement(l.Zo,{components:f},g)),r.createElement(d.a,null,i.frontmatter.tags.map((e=>r.createElement(d.V,{key:e,text:e})))),r.createElement("hr",{className:"my-10"}),r.createElement(u.Z),r.createElement("footer")),r.createElement("nav",{className:"blog-post-nav px-8 mt-8"},r.createElement("ul",{className:"flex flex-wrap justify-between list-none p-0 text-text-default"},n?r.createElement(c.Link,{to:n.fields.slug,rel:"prev"},r.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},r.createElement(s.D,{size:22,className:"text-accent-default"}),r.createElement("p",{className:"max-w-[28rem]"},n.frontmatter.title))):r.createElement("div"),a&&r.createElement(c.Link,{to:a.fields.slug,rel:"next"},r.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},r.createElement("p",{className:"max-w-[28rem]"},a.frontmatter.title),r.createElement(m.M,{size:22,className:"text-accent-default"}))))),r.createElement(p.Z,{contents:i.tableOfContents}))},b=e=>{let{data:{mdx:t}}=e;return r.createElement(i.Z,{title:t.frontmatter.title,description:t.frontmatter.description||t.excerpt})};function v(e){return r.createElement(g,e,r.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-react-darkmode-in-react-mdx-6098fd83c2f26cee285d.js.map