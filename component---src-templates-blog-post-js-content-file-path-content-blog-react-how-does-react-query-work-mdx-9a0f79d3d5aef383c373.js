"use strict";(self.webpackChunkleego_dev_log=self.webpackChunkleego_dev_log||[]).push([[352],{747:function(e,t,n){n.r(t),n.d(t,{Head:function(){return Q},default:function(){return v}});var r=n(1151),l=n(7294);function a(e){const t=Object.assign({h1:"h1",a:"a",span:"span",p:"p",code:"code",pre:"pre",h2:"h2",ol:"ol",li:"li"},(0,r.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h1,{id:"queryclient",style:{position:"relative"}},l.createElement(t.a,{href:"#queryclient","aria-label":"queryclient permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"QueryClient"),"\n",l.createElement(t.p,null,"react-query를 프로젝트에 셋팅할 때, 가장 먼저 하는 것은 앱의 최상위에서 ",l.createElement(t.code,null,"QueryClientProvider"),"로 우리의 앱을 감싸주는 일이다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n...\n\nconst queryClient = new QueryClient();\n\nfunction Root() {\n  return (\n        <QueryClientProvider client={queryClient}>\n            <App />\n        </QueryClientProvider>\n  );\n}\n")),"\n",l.createElement(t.p,null,"우리는 먼저 새로운 ",l.createElement(t.code,null,"QueryClient"),"인스턴스를 생성하고, ",l.createElement(t.code,null,"QueryClientProvider"),"를 통해 앱 전체에서 생성한 ",l.createElement(t.code,null,"QueryClient"),"에 접근 가능하도록 해준다."),"\n",l.createElement(t.p,null,"이 ",l.createElement(t.code,null,"QueryClient"),"는 단순하게 표현하자면 ",l.createElement(t.code,null,"QueryCache"),"와 ",l.createElement(t.code,null,"MutationCache"),"를 담는 그릇이다. 우리는 대부분의 경우에 직접 ",l.createElement(t.code,null,"QueryCache"),"에 접근하기보다, ",l.createElement(t.code,null,"QueryClient"),"를 통해 ",l.createElement(t.code,null,"QueryCache"),"와 ",l.createElement(t.code,null,"MutationCache"),"에 접근한다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FceNUPV%2Fbtsak9GTTBJ%2Fkayd2JfAISPXslo0C568U1%2Fimg.jpg",width:"282",className:"m-auto"}),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"QueryClientProvider"),"를 통해 내려준 ",l.createElement(t.code,null,"queryClient"),"에 접근하기 위해서는 ",l.createElement(t.code,null,"useQueryClient"),"를 사용한다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"const queryClient = useQueryClient();\n")),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"이렇게 가져온 ",l.createElement(t.code,null,"queryClient"),"객체를 ",l.createElement(t.code,null,"console"),"에 찍어보면 내부 구조를 볼 수 있다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FblQGgn%2FbtsayVgIboL%2Ft8Yzl5dYc2Q3smuFcsTIL0%2Fimg.png",width:"695",className:"m-auto"}),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 20000\n    }\n  }\n});\n")),"\n",l.createElement(t.p,null,"만약 위와 같이 ",l.createElement(t.code,null,"QueryClient")," 객체를 생성하면서 ",l.createElement(t.code,null,"defaultOption"),"을 설정해줬다면, 해당 객체에 잘 들어가 있는 것을 확인할 수 있다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtzOGA%2FbtsajdJ9NfX%2FXayNAnkAJIrvIHrZwnGebK%2Fimg.png",width:"369",className:"m-auto"}),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h1,{id:"querycache",style:{position:"relative"}},l.createElement(t.a,{href:"#querycache","aria-label":"querycache permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"QueryCache"),"\n",l.createElement(t.p,null,"위에서 살펴본 ",l.createElement(t.code,null,"QueryClient"),"객체 안에는 QueryCache가 존재한다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb3SW2I%2FbtsaEhX1n8r%2FlzaeL41GQjOAdi7KY5qXJ1%2Fimg.png",width:"546",className:"m-auto"}),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"QueryCache"),"는 javascript 객체다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"export class QueryCache extends Subscribable<QueryCacheListener> {\n\n  private queries: Query<any, any, any, any>[];\n  private queriesMap: QueryHashMap;\n...\n\nadd(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n}\n")),"\n",l.createElement(t.p,null,"우리가 Query를 생성하면, ",l.createElement(t.code,null,"queryHash"),"를 객체의 key로,\nquery 인스턴스를 값으로 넣어준다."),"\n",l.createElement(t.p,null,"그리고 ",l.createElement(t.code,null,"queries")," 라는 배열에 query 인스턴스를 추가한다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXME6Q%2Fbtsaw8UFEBT%2F6lDIT6g0i0BgsbC2IrXQIK%2Fimg.png",width:"700",className:"m-auto"}),"\n",l.createElement(t.p,null,"여기서 ",l.createElement(t.code,null,"queryHash"),"는 query key를 stringify한 값이다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n")),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fciw2GB%2Fbtsak3AcP1G%2FyIox0sBFqd6jipKpJjgFw1%2Fimg.png",width:"385",className:"m-auto"}),"\n",l.createElement(t.p,null,"따라서 우리는 query 생성시 반드시 query key로 유니크한 값을 지정해주어야 한다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h1,{id:"query",style:{position:"relative"}},l.createElement(t.a,{href:"#query","aria-label":"query permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Query"),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"QueryCache"),"의 value로 Query 객체 안에는 Query의 모든 정보들이 들어있다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fq2gPN%2Fbtsai557puT%2Ff50BoPHIz8vYAxKc2ajYek%2Fimg.png",width:"665",className:"m-auto"}),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"cache"),"에 자신이 위치한 ",l.createElement(t.code,null,"QueryCache"),"정보를 가지고 있으며, ",l.createElement(t.code,null,"observers"),"라는 배열도 가지고 있다."),"\n",l.createElement(t.p,null,"이 ",l.createElement(t.code,null,"observers"),"에는 ",l.createElement(t.code,null,"QueryObserver"),"가 담긴다. ",l.createElement(t.code,null,"Query"),"는 ",l.createElement(t.code,null,"Observer"),"를 통해 누가 자신을 구독했는지 알고, ",l.createElement(t.code,null,"Observer"),"를 통해 모든 변경사항을 알릴 수 있다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h1,{id:"queryobserver",style:{position:"relative"}},l.createElement(t.a,{href:"#queryobserver","aria-label":"queryobserver permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"QueryObserver"),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"useQuery호출 시")," ",l.createElement(t.code,null,"Observer"),"가 생성된다. 이 ",l.createElement(t.code,null,"Observer"),"를 통해 ",l.createElement(t.code,null,"Query"),"와 컴포넌트가 연결된다."),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdQJ1uj%2FbtsaJVAnGCZ%2FAWAk7PUVHYWPVlp7IT6Ygk%2Fimg.jpg",width:"265",className:"m-auto"}),"\n",l.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FECpGH%2FbtsakftRfS8%2F3lWp6zMtQnNn1PhhZ30JmK%2Fimg.png",width:"600",className:"m-auto"}),"\n",l.createElement(t.p,null,"Observer에는 QueryClient객체를 비롯하여 현재 Query, 랜더링 유발 여부를 파악하기 위한 현재 결과값 등이 담겨있다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h1,{id:"usequery-호출-시-일어나는-일",style:{position:"relative"}},l.createElement(t.a,{href:"#usequery-%ED%98%B8%EC%B6%9C-%EC%8B%9C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC","aria-label":"usequery 호출 시 일어나는 일 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"useQuery 호출 시 일어나는 일"),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"useQuery"),"를 호출하고 ",l.createElement(t.code,null,"QueryCache"),"에서 데이터를 가져오는 과정을 살펴보자."),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"Observer"),"를 생성하고, ",l.createElement(t.code,null,"queryCache"),"에서 데이터를 가져오는 핵심 로직은 모두 ",l.createElement(t.code,null,"useBaseQuery"),"에 존재한다.\nuseQuery, useQueries, useInfiniteQuery는 모두 ",l.createElement(t.code,null,"useBaseQuery"),"를 감싼 custom hook이다."),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"useBaseQuery"),"의 구조를 살펴보자."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"export function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n...\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n return result;\n")),"\n",l.createElement("br"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// useBaseQuery.ts\n\nconst queryClient = useQueryClient({ context: options.context })\n")),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"useBaseQuery")," 호출 시 가장 먼저 하는 일은 ",l.createElement(t.code,null,"QueryClient")," 객체를 가져오는 일이다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"observer-생성",style:{position:"relative"}},l.createElement(t.a,{href:"#observer-%EC%83%9D%EC%84%B1","aria-label":"observer 생성 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"observer 생성"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// useBaseQuery.ts\n\nconst [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n")),"\n",l.createElement(t.p,null,"그 이후 ",l.createElement(t.code,null,"observer"),"를 생성한다. 위에서 가져온 ",l.createElement(t.code,null,"queryClient"),"와 ",l.createElement(t.code,null,"useQuery호출 시")," 넣어준 ",l.createElement(t.code,null,"key"),"를 포함한 옵션값을 넣어준다. 이 ",l.createElement(t.code,null,"observer")," 는 ",l.createElement(t.code,null,"useState"),"를 통해 생성되었으므로, ",l.createElement(t.code,null,"useQuery"),"를 호출한 컴포넌트가 ",l.createElement(t.code,null,"unmount")," 되면 사라진다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\nconstructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n")),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"Observer")," 가 생성되면 ",l.createElement(t.code,null,"setOptions"),"를 실행한다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\nsetOptions(options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\nthis.updateQuery();\n\n...\nthis.updateResult(notifyOptions);\n\n}\n")),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"setOptions")," 은 ",l.createElement(t.code,null,"updateQuery")," 와 ",l.createElement(t.code,null,"updateResult")," 를 실행하는데, \b ",l.createElement(t.code,null,"updateQuery")," 를 좀 더 자세히 살펴보자."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\nprivate updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n")),"\n",l.createElement(t.p,null,"대략적으로 코드를 훑어보면, ",l.createElement(t.code,null,"options"),"을 가진 ",l.createElement(t.code,null,"Query")," 객체를 ",l.createElement(t.code,null,"queryCache"),"에서 찾은 후 해당 ",l.createElement(t.code,null,"Query")," 가 가지고 있는 결과값을 리턴한다는 것을 추측해 볼 수 있다. "),"\n",l.createElement(t.p,null,"하지만 여기까지의 과정에서 우리는 아직 ",l.createElement(t.code,null,"Query"),"가 생성되지 않았다는 것을 떠올려야 한다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"query-생성",style:{position:"relative"}},l.createElement(t.a,{href:"#query-%EC%83%9D%EC%84%B1","aria-label":"query 생성 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Query 생성"),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"this.client.getQueryCache().build(this.client, this.options)"),"를 좀 더 들여다보자."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryCache.ts\n\nbuild<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n")),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"Query")," 의 생성은 ",l.createElement(t.code,null,"QueryCache")," 의 ",l.createElement(t.code,null,"build")," 매서드에서 이뤄진다."),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"queryKey")," 를 stringify해서 ",l.createElement(t.code,null,"queryHash")," 를 생성"),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"QueryCache")," 에서 해당 key를 가진 ",l.createElement(t.code,null,"query"),"가 있는지 확인"),"\n",l.createElement(t.li,null,"없다면 새로운 ",l.createElement(t.code,null,"query")," 생성"),"\n"),"\n",l.createElement(t.p,null,"이제 ",l.createElement(t.code,null,"Query"),"가 생성되어 ",l.createElement(t.code,null,"cache"),"에 들어있게 되었다."),"\n",l.createElement(t.p,null,"생성한 ",l.createElement(t.code,null,"Query"),"를 return해준다."),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"다시 ",l.createElement(t.code,null,"updateQuery"),"로 돌아가보면, 이제 ",l.createElement(t.code,null,"query"),"에 막 생성한 ",l.createElement(t.code,null,"Query")," 인스턴스가 담겨있게된다."),"\n",l.createElement(t.p,null,"이 ",l.createElement(t.code,null,"Query"),"의 정보를 ",l.createElement(t.code,null,"Observer"),"에 저장해두고 만약 다시 ",l.createElement(t.code,null,"updateQuery"),"가 호출되면 새로운 ",l.createElement(t.code,null,"Query"),"와 비교해서 새로운 ",l.createElement(t.code,null,"Query")," 정보로 업데이트 해준다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\nprivate updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n    \n\t...\n    \n \tthis.currentQuery = query\n \tthis.currentQueryInitialState = query.state\n    \n \t...\n    \n}\n")),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"다음은 ",l.createElement(t.code,null,"result"),"에 결과값들을 넣어준다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// useBaseQuery.ts\n\nconst result = observer.getOptimisticResult(defaultedOptions)\n")),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\ngetOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n")),"\n",l.createElement(t.p,null,"바로 위에서 알아봤듯, ",l.createElement(t.code,null,"const query = this.client.getQueryCache().build(this.client, options)"),"은 ",l.createElement(t.code,null,"options"),"에 해당하는 ",l.createElement(t.code,null,"Query"),"를 반환하고, 없으면 ",l.createElement(t.code,null,"Query"),"를 새로 생성한다."),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"createResult"),"는 함수명 그대로 사용자가 설정한 옵션에 따라\n ",l.createElement(t.code,null,"Query"),"가 가진 데이터를 비롯한 ",l.createElement(t.code,null,"isLoading"),", ",l.createElement(t.code,null,"isStale"),", ",l.createElement(t.code,null,"status")," 등의 상태 값을 리턴해준다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// queryObserver.ts\n\n\tprotected createResult(\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n        options: QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n      ): QueryObserverResult<TData, TError> {\n  \n      ...\n        const result: QueryObserverBaseResult<TData, TError> = {\n          status,\n          fetchStatus,\n          isLoading,\n          isSuccess: status === 'success',\n          isError,\n          isInitialLoading: isLoading && isFetching,\n          data,\n          dataUpdatedAt,\n          error,\n          errorUpdatedAt,\n          failureCount: state.fetchFailureCount,\n          failureReason: state.fetchFailureReason,\n          errorUpdateCount: state.errorUpdateCount,\n          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n          isFetchedAfterMount:\n            state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n            state.errorUpdateCount > queryInitialState.errorUpdateCount,\n          isFetching,\n          isRefetching: isFetching && !isLoading,\n          isLoadingError: isError && state.dataUpdatedAt === 0,\n          isPaused: fetchStatus === 'paused',\n          isPlaceholderData,\n          isPreviousData,\n          isRefetchError: isError && state.dataUpdatedAt !== 0,\n          isStale: isStale(query, options),\n          refetch: this.refetch,\n          remove: this.remove,\n        }\n\n        return result as QueryObserverResult<TData, TError>\n  }\n")),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"결과값-리턴",style:{position:"relative"}},l.createElement(t.a,{href:"#%EA%B2%B0%EA%B3%BC%EA%B0%92-%EB%A6%AC%ED%84%B4","aria-label":"결과값 리턴 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"결과값 리턴"),"\n",l.createElement(t.p,null,"이제 마지막 줄이다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// useBaseQuery.ts\n\n// Handle result property usage tracking\nreturn !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n")),"\n",l.createElement(t.p,null,"v3까지는 ",l.createElement(t.code,null,"notifyOnChangeProps")," 을 ",l.createElement(t.code,null,"'tracked'")," 로 설정해야 실제 사용하고 있는 속성이 변경되는 경우에만 리렌더링을 해주었다. 하지만 v4에서는 이 설정이 기본값이 되었다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n")),"\n",l.createElement(t.p,null,"query에서 가져온 result는 ",l.createElement(t.code,null,"observer.trackResult")," 를 통해 실제 사용하고 있는 속성들을 ",l.createElement(t.code,null,"trackedProps")," 에 넣고 관리한다. ",l.createElement(t.code,null,"trackedProps"),"에 속한 속성들이 변경됐을때만 리랜더링을 발생시킨다.\n",l.createElement(t.code,null,"notifyOnChangeProps"),"을 ",l.createElement(t.code,null,"‘all’")," 로 해주면 v3의 기본 설정처럼 result에 포함된 모든 속성이 변경될 때마다 리렌더링을 야기한다."),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"useQuery"),"를 호출하면,\n",l.createElement(t.code,null,"Observer"),"가 생성되고 ",l.createElement(t.code,null,"Query"),"를 생성한 후 ",l.createElement(t.code,null,"Query"),"의 ",l.createElement(t.code,null,"result"),"를 가져와 반환하는 과정을 알아보았다."),"\n",l.createElement(t.p,null,"하나의 ",l.createElement(t.code,null,"Query"),"에 대하여 ",l.createElement(t.code,null,"useQuery"),"는 여러번 호출될 수 있고, 이는 하나의 ",l.createElement(t.code,null,"Query"),"에 대하여 여러개의 ",l.createElement(t.code,null,"Observer"),"를 생성할 수 있다는 것을 의미한다."),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"그렇다면 ",l.createElement(t.code,null,"observer"),"는 ",l.createElement(t.code,null,"Query"),"의 변화를 어렇게 알아챌까?"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"// useBaseQuery.ts\n\nuseSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n")),"\n",l.createElement(t.p,null,"모든 observer는 ",l.createElement(t.code,null,"useSyncExternalStore")," 라는 hook를 통해 query 데이터의 변화를 감지한다."),"\n",l.createElement(t.p,null,"여기서 모든걸 다루게 되면 포스팅이 너무 길어지기 때문에, ",l.createElement(t.code,null,"useSyncExternalStore")," 에 대해서는 다음 포스팅으로 넘기겠다."),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(t.h1,{id:"참고-",style:{position:"relative"}},l.createElement(t.a,{href:"#%EC%B0%B8%EA%B3%A0-","aria-label":"참고  permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"참고 📌"),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"https://github.com/TanStack/query/blob/main/packages/react-query/src/useBaseQuery.ts"},"https://github.com/TanStack/query/blob/main/packages/react-query/src/useBaseQuery.ts")),"\n",l.createElement(t.p,null," ",l.createElement(t.a,{href:"https://github.com/TanStack/query/blob/main/packages/react-query/src/useBaseQuery.ts"},"GitHub - TanStack/query")),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"https://tkdodo.eu/blog/inside-react-query"},"https://tkdodo.eu/blog/inside-react-query")),"\n",l.createElement(t.p,null," ",l.createElement(t.a,{href:"https://tkdodo.eu/blog/inside-react-query"},"Inside React Query")))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?l.createElement(t,e,l.createElement(a,e)):a(e)},u=n(1883),s=n(157),o=n(588),i=n(8709),m=n(9357),d=n(7174),y=n(4462),E=n(8336),h=n(1075);const p={img:e=>{let{src:t,alt:n}=e;return l.createElement("img",{src:t,alt:n,className:"m-auto md:w-3/4"})},pre:y.d,code:e=>l.createElement("code",Object.assign({},e,{className:"bg-background-primary text-accent-default bg-opacity-70"}))},b=e=>{var t;let{data:{previous:n,next:a,site:c,mdx:m},location:y,children:b}=e;const Q=(null===(t=c.siteMetadata)||void 0===t?void 0:t.title)||"Title";return l.createElement(i.Z,{location:y,title:Q},l.createElement("article",{className:"blog-post px-8 pt-10",itemScope:!0,itemType:"http://schema.org/Article"},l.createElement("header",{className:"text-center py-14"},l.createElement("h1",{itemProp:"headline"},m.frontmatter.title),l.createElement("p",{className:"text-accent-default text-xs mt-8"},m.frontmatter.date)),l.createElement("section",{className:"h-fit my-28 text-text-default",itemProp:"articleBody"},l.createElement(r.Zo,{components:p},b)),l.createElement(d.a,null,m.frontmatter.tags.map((e=>l.createElement(d.V,{key:e,text:e})))),l.createElement("hr",{className:"my-10"}),l.createElement(E.Z),l.createElement("footer")),l.createElement("nav",{className:"blog-post-nav px-8 mt-8"},l.createElement("ul",{className:"flex flex-wrap justify-between list-none p-0 text-text-default"},n?l.createElement(u.Link,{to:n.fields.slug,rel:"prev"},l.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},l.createElement(o.D,{size:22,className:"text-accent-default"}),l.createElement("p",{className:"max-w-[28rem]"},n.frontmatter.title))):l.createElement("div"),a&&l.createElement(u.Link,{to:a.fields.slug,rel:"next"},l.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},l.createElement("p",{className:"max-w-[28rem]"},a.frontmatter.title),l.createElement(s.M,{size:22,className:"text-accent-default"}))))),l.createElement(h.Z,{contents:m.tableOfContents}))},Q=e=>{let{data:{mdx:t}}=e;return l.createElement(m.Z,{title:t.frontmatter.title,description:t.frontmatter.description||t.excerpt})};function v(e){return l.createElement(b,e,l.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-react-how-does-react-query-work-mdx-9a0f79d3d5aef383c373.js.map