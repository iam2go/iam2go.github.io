"use strict";(self.webpackChunkleego_dev_log=self.webpackChunkleego_dev_log||[]).push([[881],{7723:function(e,t,n){n.r(t),n.d(t,{Head:function(){return f},default:function(){return v}});var l=n(1151),a=n(7294);function c(e){const t=Object.assign({p:"p",em:"em",code:"code",h1:"h1",a:"a",span:"span",ul:"ul",li:"li",pre:"pre",strong:"strong",br:"br"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.p,null,a.createElement(t.em,null,a.createElement(t.code,null,"useCallback"),"과 ",a.createElement(t.code,null,"useMemo"),"는 메모이제이션 된 값을 반환한다. 차이점은 ",a.createElement(t.code,null,"useCallback"),"은 함수를 메모이제이션하고 ",a.createElement(t.code,null,"useMemo"),"는 값을 메모이제이션한다.")),"\n",a.createElement(t.p,null,"면접을 준비하여 외웠던 대답이다. 실제 프로젝트를 하면서 ",a.createElement(t.code,null,"useCallback"),"을 써봤지만 왜 쓰는지, 언제 써야하는지를 정확히 이해하지 못했었다.(심지어는 전혀 이점없는 곳에 썼다🙄) 회사에 와서야 ",a.createElement(t.code,null,"useCallback"),"과 ",a.createElement(t.code,null,"useMemo"),"를 사용하는 목적이 무엇인지를 완전히 이해하고 올바르게 사용하게 되었다. 이제 내가 이해한 내용을 여기에 정리해보려한다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"react의-리렌더링",style:{position:"relative"}},a.createElement(t.a,{href:"#react%EC%9D%98-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81","aria-label":"react의 리렌더링 permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"REACT의 리렌더링"),"\n",a.createElement(t.p,null,"React가 리렌더링을 하는 조건은 3가지이다."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"자신의 state가 변경될 때"),"\n",a.createElement(t.li,null,"부모 컴포넌트로부터 전달받은 props가 변경될 때"),"\n",a.createElement(t.li,null,"부모 컴포넌트가 리렌더링 될 때"),"\n"),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"여기 간단한 앱이 있다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// App.js\n\nfunction App() {\n  const [number, setNumber] = useState(0);\n  return (\n    <div className="App">\n      <div className="num" onClick={()=>{setNumber(number+1)}}>{number}</div> \n      <Button/>\n    </div>\n  );\n}\n\nexport default App;\n')),"\n",a.createElement(t.p,null,"숫자를 클릭하면 숫자가 1씩 증가하는 앱이다. 아래에는 버튼을 만들어 주었다."),"\n",a.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAWIbK%2FbtreMDwFbYq%2FjlwHVmtN3JPJe5kKttEuHK%2Fimg.png",width:"439",className:"m-auto"}),"\n",a.createElement(t.p,null,"실행한 모습은 위와 같다."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"Button"),"컴포넌트는 props가 없는 순수 UI컴포넌트이다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// Button.js\n\nfunction Button() {\n    return (\n      <button className="button">RESET</button>\n    );\n  }\n\n  export default Button;\n')),"\n",a.createElement(t.p,null,"이 컴포넌트는 항상 같은 결과를 return하지만 '",a.createElement(t.em,null,"부모 컴포넌트가 리렌더링 될 때 자식 컴포넌트로 리렌더링 된다."),"' 라는 조건에 따라 ",a.createElement(t.strong,null,"부모 컴포넌트가 리렌더링 될 때 항상 리렌더링된다"),"."),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/bpQLxq/btreJxLrFaK/lyTtEovXpb5UD62mtuagO0/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"물론 지금과 같이 매우 간단한 앱에서는 불필요한 리렌더링이 몇번이고 일어나든 성능에 문제되지 않는다. 하지만 만약 Button이라는 컴포넌트가 엄청 복잡하고 값비싼 코드를 포함하는 컴포넌트라면 어떨까?  리렌더링을 최대한 줄여야할 것이다. ",a.createElement(t.br),"\n","그렇다면 이 불필요한 리렌더링을 막을 방법은 무엇일까?"),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"바로 ",a.createElement(t.code,null,"React.memo"),"를 사용하면 된다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"-reactmemo를-알아보자",style:{position:"relative"}},a.createElement(t.a,{href:"#-reactmemo%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90","aria-label":" reactmemo를 알아보자 permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"👀 React.memo를 알아보자"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"React.memo")," 는 ",a.createElement(t.strong,null,"컴포넌트를 메모이제이션"),"해준다."),"\n",a.createElement(t.p,null,"부모 컴포넌트로 넘겨받는 props가 같다면 메모이제이션 해둔 렌더링 결과를 가져온다. 메모이제이션한 내용을 재사용하여 렌더링시 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점이 생기게 된다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"const MyComponent = React.memo(function MyComponent(props) {\n  /* props를 사용하여 렌더링 */\n});\n")),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"function MyComponent(props) {\n  /* props를 사용하여 렌더링 */\n}\nexport default React.memo(MyComponent, areEqual);\n")),"\n",a.createElement(t.p,null,"위와 같이 컴포넌트를 감싸주는 방식으로 사용하면 된다."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"그럼 ",a.createElement(t.code,null,"Button")," 컴포넌트를 ",a.createElement(t.code,null,"React.memo"),"로 감싸보자."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// Button.js\n\nfunction Button() {\n    return (\n      <button className="button">RESET</button>\n    );\n  }\n\n  export default React.memo(Button);\n')),"\n",a.createElement(t.p,null,"이제 버튼 부분은 리렌더링 되지 않는것을 확인할 수 있다."),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/3V3lo/btreOt1B9L6/htSuXyD7WtwSjU9xD7gTI0/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"현재 버튼은 아무런 동작도 일으키지 못한다."),"\n",a.createElement(t.p,null,"버튼이 제역할을 하기위해 ",a.createElement(t.code,null,"RESET"),"버튼을 클릭하면 숫자가 0으로 리셋되도록 구현해주었다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// App.js\n\nconst onClick = () => {\n    setNumber(0);\n  }\n\n  return (\n    <div className="App">\n      <div className="num" onClick={()=>{setNumber(number+1)}}>{number}</div> \n      <Button onClick={onClick}/>\n    </div>\n  );\n')),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"onClick"),"함수를 만들고 ",a.createElement(t.code,null,"Button"),"컴포넌트에 넘겨주었다."),"\n",a.createElement("br"),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// Button.js\n\nfunction Button({onClick}) {\n    return (\n      <button className="button" onClick={onClick}>RESET</button>\n    );\n  }\n\n  export default React.memo(Button);\n')),"\n",a.createElement(t.p,null,"이제 다시 앱을 실행시켜서 버튼이 제 역할을 잘 하는지 확인해보자. 버튼은 잘 동작한다. 그런데 숫자를 클릭하면 버튼이 다시 리랜더링 되는 현상을 발견할 수 있다."),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/baE9aI/btrePWW4kQ4/IfZxHctgy3Y3JaF9U7TYvK/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"왜 ",a.createElement(t.code,null,"React.memo"),"가 제 기능을 못하는 걸까🤔?"),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"object--object",style:{position:"relative"}},a.createElement(t.a,{href:"#object--object","aria-label":"object  object permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),a.createElement(t.code,null,"object")," !== ",a.createElement(t.code,null,"object")),"\n",a.createElement(t.p,null,"리렌더링이 발생되면 해당 컴포넌트의 모든 객체들은 다시 생성된다.( ❗ 함수도 객체이다. ) ",a.createElement(t.strong,null,"javascript에서 객체는 참조타입으로 완전히 동일한 값을 가지고 있더라도 참조하는 주소가 다르면 서로 다른 객체로 취급된다.")),"\n",a.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd4h66k%2FbtrePW3x0ry%2Frz289a5fkKWHGPXCaUhUv0%2Fimg.png",width:"300",className:"m-auto"}),"\n",a.createElement(t.p,null,"b는 a의 주소값을 복사했기 때문에 동일한 객체라 인식하지만,"),"\n",a.createElement(t.p,null,"a와 값이 동일한 객체는 a와 주소값이 다르기 때문에 다른 객체라 판단한다."),"\n",a.createElement(t.p,null,"즉, 컴포넌트는 리렌더링할 때 마다 새로운 함수를 계속 생성하며, ",a.createElement(t.code,null,"React.memo"),"는 부모 컴포넌트로 넘겨받는 props가 변경되었다고 판단하여 계속 리렌더링 하는 것이다."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"useCallback"),"과 ",a.createElement(t.code,null,"useMemo")," 는 여기서 발생하는 불필요한 렌더링과 불필요한 계산을 방지하는 목적으로 설계되었다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"usecallback",style:{position:"relative"}},a.createElement(t.a,{href:"#usecallback","aria-label":"usecallback permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),a.createElement(t.code,null,"useCallback")),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"useCallback")," 은 언제나 동일한 함수를 return해준다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"const memoizedCallback = useCallback(\n  () => {\n    doSomething(a, b);\n  },\n  [a, b], // deps\n);\n")),"\n",a.createElement(t.p,null,"deps안에 넣어준 값이 바뀔때에만 새로운 객체를 생성한다."),"\n",a.createElement(t.p,null,"React.memo로 감싸준 자식 컴포넌트에게 함수를 prop로 넘겨줄 경우, 넘겨받는 함수를 ",a.createElement(t.code,null,"useCallback"),"으로 감싸주면 ",a.createElement(t.code,null,"deps")," 가 바뀔 경우를 제외하고 항상 동일한 객체를 넘겨줌으로 불필요한 리렌더링을 방지할 수 있다."),"\n",a.createElement("br"),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"// App.js\n\nfunction App() {\n  ...\n  const onClick = useCallback(() => {\n      setNumber(0);\n    },[]);\n    ...\n}\n")),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"Button"),"컴포넌트에 넘겨주는 ",a.createElement(t.code,null,"onClick")," 함수를 ",a.createElement(t.code,null,"useCallback"),"으로 감싸주게 되면, Button의 불필요한 리렌더링이 방지된다."),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/cGfwcy/btreLLobstc/tQrH6eAk9iUo5kIfBlg0Gk/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.h1,{id:"usememo",style:{position:"relative"}},a.createElement(t.a,{href:"#usememo","aria-label":"usememo permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),a.createElement(t.code,null,"useMemo")),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"useMemo"),"도 ",a.createElement(t.code,null,"useCallback"),"과 동일한 방식으로 사용하면 된다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n")),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"Button"),"이 공통컴포넌트이고 상황에 따라 style을 커스텀 할 수 있게 props로 ",a.createElement(t.code,null,"style"),"을 넘겨준다고 가정해보자."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// App.js\n\nfunction App() {\n  ...\n  return (\n      <div className="App">\n        <div className="num" onClick={()=>{setNumber(number+1)}}>{number}</div> \n        <Button onClick={onClick} style={{backgroundColor: \'darkseagreen\'}}/>\n      </div>\n    );\n    ...\n}\n')),"\n",a.createElement(t.p,null,"react에서 인라인으로 객체를 넣으면 위에서 설명했듯이, 리렌더링시마다 새로운 객체가 생성된다. 따라서 ",a.createElement(t.code,null,"Button"),"은 계속 리렌더링 된다."),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/DPQ9i/btreJn2YxpC/CCLrW5GbAG3pCwJUIRZ3ek/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"이때, ",a.createElement(t.code,null,"useMemo"),"를 사용해서 객체를 메모이제이션 해줌으로 ",a.createElement(t.code,null,"style")," prop에 대해 동일한 참조를 제공할 수 있다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,'// App.js\n\nfunction App() {\n  ...\n\tconst buttonStyle = useMemo(() => ({backgroundColor: \'darkseagreen\'}), []);\n\n  return (\n    <div className="App">\n      <div className="num" onClick={()=>{setNumber(number+1)}}>{number}</div> \n      <Button onClick={onClick} style={buttonStyle}/>\n    </div>\n  );\n  ...\n  \n }\n')),"\n",a.createElement("img",{src:"https://blog.kakaocdn.net/dn/b5lWih/btreKk5VZlR/a4Wosj6EJrMgz0zSs2voj0/img.gif",width:"439",className:"m-auto"}),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"❗ ",a.createElement(t.code,null,"deps"),"가 빈 배열인 이유는 위의 예시에서는 해당 함수나 값이 의존하는 변수가 없기 때문이다. 의존하는 값이 존재하는 경우에는 반드시 ",a.createElement(t.code,null,"deps")," 배열안에 명시해줘야 한다."),"\n",a.createElement("img",{src:"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmQHDL%2FbtreJQRQxjr%2Fb3L99MJRGYlNUw8mV11G81%2Fimg.png",width:"500",className:"m-auto"}),"\n",a.createElement(t.h1,{id:"참조-",style:{position:"relative"}},a.createElement(t.a,{href:"#%EC%B0%B8%EC%A1%B0-","aria-label":"참조  permalink",className:"anchor before"},a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"참조 📌"),"\n",a.createElement(t.p,null,a.createElement(t.a,{href:"https://alexsidorenko.com/blog/react-render-usememo/"},"deps 이미지 출처")))}var r=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(c,e)):c(e)},m=n(1883),o=n(157),u=n(588),s=n(8709),i=n(9357),E=n(7174),d=n(4462),p=n(8336),b=n(1075);const h={img:e=>{let{src:t,alt:n}=e;return a.createElement("img",{src:t,alt:n,className:"m-auto md:w-3/4"})},pre:d.d,code:e=>a.createElement("code",Object.assign({},e,{className:"bg-background-primary text-accent-default bg-opacity-70"}))},g=e=>{var t;let{data:{previous:n,next:c,site:r,mdx:i},location:d,children:g}=e;const f=(null===(t=r.siteMetadata)||void 0===t?void 0:t.title)||"Title";return a.createElement(s.Z,{location:d,title:f},a.createElement("article",{className:"blog-post px-8 pt-10",itemScope:!0,itemType:"http://schema.org/Article"},a.createElement("header",{className:"text-center py-14"},a.createElement("h1",{itemProp:"headline"},i.frontmatter.title),a.createElement("p",{className:"text-accent-default text-xs mt-8"},i.frontmatter.date)),a.createElement("section",{className:"h-fit my-28 text-text-default",itemProp:"articleBody"},a.createElement(l.Zo,{components:h},g)),a.createElement(E.a,null,i.frontmatter.tags.map((e=>a.createElement(E.V,{key:e,text:e})))),a.createElement("hr",{className:"my-10"}),a.createElement(p.Z),a.createElement("footer")),a.createElement("nav",{className:"blog-post-nav px-8 mt-8"},a.createElement("ul",{className:"flex flex-wrap justify-between list-none p-0 text-text-default"},n?a.createElement(m.Link,{to:n.fields.slug,rel:"prev"},a.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},a.createElement(u.D,{size:22,className:"text-accent-default"}),a.createElement("p",{className:"max-w-[28rem]"},n.frontmatter.title))):a.createElement("div"),c&&a.createElement(m.Link,{to:c.fields.slug,rel:"next"},a.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},a.createElement("p",{className:"max-w-[28rem]"},c.frontmatter.title),a.createElement(o.M,{size:22,className:"text-accent-default"}))))),a.createElement(b.Z,{contents:i.tableOfContents}))},f=e=>{let{data:{mdx:t}}=e;return a.createElement(i.Z,{title:t.frontmatter.title,description:t.frontmatter.description||t.excerpt})};function v(e){return a.createElement(g,e,a.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-react-profer-usage-of-usecallback-usememo-mdx-d3eb1c2da51b86f88233.js.map