"use strict";(self.webpackChunkleego_dev_log=self.webpackChunkleego_dev_log||[]).push([[656],{1361:function(e,t,n){n.r(t),n.d(t,{Head:function(){return S},default:function(){return f}});var l=n(1151),r=n(7294);function a(e){const t=Object.assign({p:"p",h1:"h1",a:"a",span:"span",h2:"h2",code:"code",strong:"strong",pre:"pre",ol:"ol",li:"li"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"HTTP프로토콜은 비연결성을 가진 프로토콜이다. 클라이언트가 서버에 요청을 보내면, 서버는 그 요청에 대한 응답을 완료한 후 연결을 끊는다. 이러한 특성때문에 서버와 지속적인 커넥션이 필요한 상황에서는 불편함이 발생할 수 있다. 실시간으로 서버로부터 데이터를 받아야 하는  채팅, 알림서비스처럼 실시간으로 서버에서 데이터를 받아야 하는 경우 HTTP의 기본 요청 -응답 방식만으로는 원할한 기능 구현이 힘들다."),"\n",r.createElement(t.p,null,"이를 해결하기 위해 활용되는 기술이 Polling, Long Polling, WebSocket, Server-Sent Events이다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"실시간-데이터-통신-기술",style:{position:"relative"}},r.createElement(t.a,{href:"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0","aria-label":"실시간 데이터 통신 기술 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"실시간 데이터 통신 기술"),"\n",r.createElement(t.h2,{id:"polling",style:{position:"relative"}},r.createElement(t.a,{href:"#polling","aria-label":"polling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Polling"),"\n",r.createElement(t.p,null,"클라이언트가 주기적으로 서버로 요청을 보내서 응답을 확인하는 방식이다. 구현이 간단하고 모든 브라우저에서 지원되지만 자주 요청을 보내야 하기 때문에 서버에 부하가 될 수 있으며, 즉각적인 응답이 어려울 수 있다."),"\n",r.createElement(t.h2,{id:"long-polling",style:{position:"relative"}},r.createElement(t.a,{href:"#long-polling","aria-label":"long polling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Long Polling"),"\n",r.createElement(t.p,null,"클라이언트가 한번 요청을 보내고 일정시간동안 서버의 응답을 기다리는 방식이다. 서버는 새로운 데이터가 있을 때만 응답을 보내고, 이후 클라이언트는 다시 서버에게 요청을 보낸다. Polling에 비해 서버 리소스를 절약하며, 상대적으로 실시간성을 보장하지만 상태 변경이 빈번하게 발생한다면 Polling과 차이가 없어진다."),"\n",r.createElement(t.h2,{id:"websoket",style:{position:"relative"}},r.createElement(t.a,{href:"#websoket","aria-label":"websoket permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"WebSoket"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"ws")," ,",r.createElement(t.code,null,"wss")," 프로토콜을 사용하여 서버와 브라우저 간 연결을 유지한 상태로 데이터를 교환하는 방식이다. 데이터는 패킷(packet) 형태로 전달되며, 전송은 커넥션 중단과 추가 HTTP 요청 없이 양방향으로 이뤄진다."),"\n",r.createElement(t.h2,{id:"sse-server-sent-event",style:{position:"relative"}},r.createElement(t.a,{href:"#sse-server-sent-event","aria-label":"sse server sent event permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"SSE (Server-Sent Event)"),"\n",r.createElement(t.p,null,"그리고 이제 SSE가 있다."),"\n",r.createElement(t.p,null,"SSE역시 서버와 브라우저간 연결을 유지한다. 언뜻보면 웹소켓과 비슷하지만 아래와 같은 차이점이있다."),"\n",r.createElement("table",null,r.createElement("tr",null,r.createElement("th",null,"WebSocket "),r.createElement("th",null,"EventSource")),r.createElement("tr",null,r.createElement("td",null,"양방향통신. ",r.createElement("br")," 클라이언트와 서버가 서로 메세지를 교환"),r.createElement("td",null,"단방향통신. 서버만 데이터 전송")),r.createElement("tr",null,r.createElement("td",null," Binary and text data "),r.createElement("td",null," Only text")),r.createElement("tr",null,r.createElement("td",null," WebSocket protocol  "),r.createElement("td",null," 일반 HTTP"))),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"WebSocket은 양방향 통신이 가능하기 때문에 다양한 실시간 데이터 전송에 유용하지만, 양방향이 필요 없는 경우에는 다소 과한 감이 있다.서버에서 데이터만 받아오면 되는 경우라면 단방향 통신인 SSE가 더 적합하다."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"나같은 경우, AI의 응답을 실시간으로 받아오기 위해 SSE 방식을 활용했다. 서버에서 클라이언트로 데이터만 전달되므로 양방향 통신이 필요하지 않았기 때문이다."),"\n",r.createElement(t.p,null,"문제 텍스트를 서버로 전송하고 이에 대한 답변을 실시간으로 받아와야 했는데, 문제 텍스트의 길이가 길어 ",r.createElement(t.strong,null,"POST 요청"),"을 사용했다.\n평소 프로젝트에서는 주로 Axios를 활용했지만, Axios는 POST 방식으로 SSE (Server-Sent Events)를 지원하지 않기 때문에 이번엔 ",r.createElement(t.strong,null,"fetch API"),"를 사용하여 구현했다."),"\n",r.createElement(t.p,null,"동일한 이유로, 일반적으로 SSE를 구현할때 ",r.createElement(t.code,null,"EventSource")," 객체를 많이 사용하지만 ",r.createElement(t.code,null,"EventSource"),"는 GET 요청만 지원하므로 때문에 ",r.createElement(t.code,null,"ReadableStream"),"을 사용하여 SSE를 구현했다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h1,{id:"sse-구현",style:{position:"relative"}},r.createElement(t.a,{href:"#sse-%EA%B5%AC%ED%98%84","aria-label":"sse 구현 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"SSE 구현"),"\n",r.createElement(t.p,null,"답변을 받아오는 매서드의 전체 코드는 아래와 같다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"const getAnswer = async (index: number) => {\n    let text = '';\n\n    try {\n        const controller = new AbortController();\n        controllerRef.current = controller;\n\n        // 서버로부터 스트리밍 데이터를 받아옴\n        const response = await getAnswerStream(questionList[questionNo].question_text, controller.signal);\n        if (!response.ok || !response.body) throw new Error('');\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        \n        let resultNo: number | null = null; // 문제 정답\n        let incompleteChunk = '';\n\n        // 스트리밍 데이터 처리\n        await processStream(reader, decoder, (chunk: string) => {\n            const { parsedDataList, remain } = parseJSONStream(chunk, incompleteChunk);\n            incompleteChunk = remain;\n\n            // 추출한 데이터 텍스트에 추가, 상태 업데이트\n            text = updateTextAndState(parsedDataList, text);\n            // result_no를 전달받았다면, resultNo에 삽입\n            if (parsedDataList[parsedDataList.length - 1]?.result_no) {\n               resultNo = parseInt(parsedDataList[parsedDataList.length - 1].result_no)\n            }\n        });\n\n        // 답변 완료\n        completeAnswerProcessing(questionNo, resultNo, text);\n    } catch (error) {\n        handleError(error, questionNo, text);\n    }\n};\n")),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"데이터-요청",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9A%94%EC%B2%AD","aria-label":"데이터 요청 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"데이터 요청"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"/**\n * @description 문제풀이 요청 (text/event-stream 형식으로 문제풀이를 요청합니다.)\n */\nexport const getAnswerStream = async (\n    questionText: string,\n    signal: AbortSignal\n): Promise<Response> => {\n    }\n    const response = await fetch(url, {\n            method: 'POST',\n            credentials: 'omit',\n            signal,\n            headers: {\n                'Content-Type': 'application/json',\n                cno: companyNo,\n            },\n            body: JSON.stringify({ question: questionText }),\n        });\n        \n     return response;\n}\n")),"\n",r.createElement(t.p,null,"서버에 데이터를 요청하는 API 호출 매서드는 위와 같다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"const controller = new AbortController();\ncontrollerRef.current = controller;\n\nconst response = await getAnswerStream(questionList[questionNo].question_text, controller.signal);\n")),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"getAnswer")," 매서드에서 ",r.createElement(t.code,null,"AbortController")," 객체를 생성하여 ",r.createElement(t.code,null,"getAnswerStream")," 호출시 두번째 인자로 signal을 넘겨주었다.\n이 signal을 fetch요청에 삽입하여 필요 시 요청을 중단할 수 있도록 구현했다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"스트림-데이터-처리",style:{position:"relative"}},r.createElement(t.a,{href:"#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC","aria-label":"스트림 데이터 처리 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"스트림 데이터 처리"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"processStream")," 매서드는 서버에서 반환된 ",r.createElement(t.code,null,"ReadableStream"),"을 읽어 들여 수신된 데이터를 부분적으로 처리한다. 각 데이터 조각이 수신될 때마다 chunk로 전달되며, 이 데이터를 JSON 형태로 파싱하여 필요한 데이터를 추출한다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"const processStream = async (\n    reader: ReadableStreamDefaultReader<Uint8Array>, \n    decoder: TextDecoder, \n    onChunkReceived: (chunk: string) => void\n) => {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value);\n        onChunkReceived(chunk);\n    }\n};\n")),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"getReader()"),"를 통해 읽어온 스트림은 보통 청크 단위의 바이너리 데이터(Uint8Array) 형태로 제공된다. 따라서 ",r.createElement(t.code,null,"decoder.decode(value)")," 를 통해 스트림을 문자열로 변환한다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"서버에서 수신하는 ",r.createElement(t.code,null,"chunk")," 값이 항상 완전한 JSON 형식으로 도착하는 것은 아니었다. 특히 JSON 데이터가 잘려서 여러 개의 청크로 나뉘어 전송될 경우, 파싱 과정에서 오류가 발생할 위험이 있었다. 이 문제를 해결하기 위해 ",r.createElement(t.code,null,"incompleteChunk")," 변수를 사용하여 불완전한 청크들을 임시로 저장하고, 다음 청크를 수신할 때 이를 합쳐 완전한 JSON 형식으로 파싱하도록 처리했다."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"예를 들어, 데이터가 다음과 같이 두 개의 청크로 나뉘어 수신된다고 하자."),"\n",r.createElement("br"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"첫 번째 청크: ",r.createElement(t.code,null,"\"{ text: '이렇게' } {text: '오고'} {text: '어쩔때는'} {text: '잘\"")),"\n",r.createElement(t.li,null,"두 번째 청크: ",r.createElement(t.code,null,"\"려서옵니다' } { text: 'TT' }\"")),"\n"),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"첫 번째 청크를 처리할 때 ",r.createElement(t.code,null,"parsedDataList"),"에는 ",r.createElement(t.code,null,"[ { text: '이렇게' }, { text: '오고' }, { text: '어쩔때는' } ]"),"와 같이 완전한 JSON 객체들만 담기고, 불완전한 JSON 데이터 ",r.createElement(t.code,null,'"{text: \'잘"'),"는 ",r.createElement(t.code,null,"remain"),"에 저장된다."),"\n",r.createElement(t.p,null,"다음 청크를 수신시 이 ",r.createElement(t.code,null,"remain")," 값을 새로운 청크와 결합하여 완전한 JSON 형태로 재구성한다. ",r.createElement(t.code,null,"parsedDataList"),"에 ",r.createElement(t.code,null,"\"{ text: '잘려서옵니다' } { text: 'TT' }\"")," 가 담기게된다."),"\n",r.createElement("br"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"await processStream(reader, decoder, (chunk: string) => {\n            const { parsedDataList, remain } = parseJSONStream(chunk, incompleteChunk);\n            incompleteChunk = remain;\n\n        });\n")),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"답변-업데이트",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8B%B5%EB%B3%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8","aria-label":"답변 업데이트 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"답변 업데이트"),"\n",r.createElement(t.p,null,"추출한 데이터를 기존 텍스트에 추가하고,  실시간으로 state를 업데이트하여 사용자에게 반영된 답변을 보여준다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"const updateTextAndState = (parsedDataList: Record<string, string>[], currentText: string) => {\n    const newStreamText = parsedDataList.map(({ text }) => text ?? '').join('');\n    setStreamText(prev => prev + newStreamText);\n    return currentText + newStreamText;\n};\n")),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"답변-완료",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8B%B5%EB%B3%80-%EC%99%84%EB%A3%8C","aria-label":"답변 완료 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"답변 완료"),"\n",r.createElement(t.p,null,"문제에 대한 답변이 모두 완료되면 ",r.createElement(t.code,null,"completeAnswerProcessing")," 를 호출한다."),"\n",r.createElement(t.pre,null,r.createElement(t.code,null,"const completeAnswerProcessing = (questionNo: number, resultNo: number | null, text: string) => {\n    updateQuestion(questionNo, resultNo, text);\n    if (questionList.length > questionNo + 1) {\n        moveOnNextQuestion(questionNo);\n    } else {\n        setIsAnswering(false);\n        addToast({ type: 'success', message: '문제풀이가 완료되었습니다.' });\n    }\n};\n")),"\n",r.createElement(t.p,null,"해당 문제에 대한 답변을 최종적으로 저장한 후 다음 문제로 넘어간다. 만약 마지막 문제라면, 문제풀이를 종료한다."),"\n",r.createElement("br"),"\n",r.createElement("br"),"\n",r.createElement(t.h2,{id:"답변-중지",style:{position:"relative"}},r.createElement(t.a,{href:"#%EB%8B%B5%EB%B3%80-%EC%A4%91%EC%A7%80","aria-label":"답변 중지 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"답변 중지"),"\n",r.createElement(t.pre,null,r.createElement(t.code,null," const onCancelAnswering = () => {\n        if (controllerRef.current) {\n            controllerRef.current.abort()\n        }\n    }\n")),"\n",r.createElement(t.p,null,"답변 생성을 중지할때는 ",r.createElement(t.code,null,"onCancelAnswering")," 를 호출하여 요청을 중단한다.\n",r.createElement(t.code,null,"controllerRef.current")," 에는 ",r.createElement(t.code,null,"AbortController"),"  가 담겨져 있으므로, ",r.createElement(t.code,null,"controllerRef.current.abort()")," 를 호출해 진행 중인 스트림을 중단하고 서버와의 연결을 종료한다."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?r.createElement(t,e,r.createElement(a,e)):a(e)},o=n(1883),s=n(157),i=n(588),m=n(8709),u=n(9357),d=n(7174),E=n(4462),h=n(8336),p=n(1075);const v={img:e=>{let{src:t,alt:n}=e;return r.createElement("img",{src:t,alt:n,className:"m-auto md:w-3/4"})},pre:E.d,code:e=>r.createElement("code",Object.assign({},e,{className:"bg-background-primary text-accent-default bg-opacity-70"}))},g=e=>{var t;let{data:{previous:n,next:a,site:c,mdx:u},location:E,children:g}=e;const S=(null===(t=c.siteMetadata)||void 0===t?void 0:t.title)||"Title";return r.createElement(m.Z,{location:E,title:S},r.createElement("article",{className:"blog-post px-8 pt-10",itemScope:!0,itemType:"http://schema.org/Article"},r.createElement("header",{className:"text-center py-14"},r.createElement("h1",{itemProp:"headline"},u.frontmatter.title),r.createElement("p",{className:"text-accent-default text-xs mt-8"},u.frontmatter.date)),r.createElement("section",{className:"h-fit my-28 text-text-default",itemProp:"articleBody"},r.createElement(l.Zo,{components:v},g)),r.createElement(d.a,null,u.frontmatter.tags.map((e=>r.createElement(d.V,{key:e,text:e})))),r.createElement("hr",{className:"my-10"}),r.createElement(h.Z),r.createElement("footer")),r.createElement("nav",{className:"blog-post-nav px-8 mt-8"},r.createElement("ul",{className:"flex flex-wrap justify-between list-none p-0 text-text-default"},n?r.createElement(o.Link,{to:n.fields.slug,rel:"prev"},r.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},r.createElement(i.D,{size:22,className:"text-accent-default"}),r.createElement("p",{className:"max-w-[28rem]"},n.frontmatter.title))):r.createElement("div"),a&&r.createElement(o.Link,{to:a.fields.slug,rel:"next"},r.createElement("li",{className:"bg-background-primary/50 text-sm p-3 rounded-xl h-fit flex items-center gap-3"},r.createElement("p",{className:"max-w-[28rem]"},a.frontmatter.title),r.createElement(s.M,{size:22,className:"text-accent-default"}))))),r.createElement(p.Z,{contents:u.tableOfContents}))},S=e=>{let{data:{mdx:t}}=e;return r.createElement(u.Z,{title:t.frontmatter.title,description:t.frontmatter.description||t.excerpt})};function f(e){return r.createElement(g,e,r.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-content-blog-tech-sse-with-post-request-mdx-6a5ecd1297527d35b52b.js.map